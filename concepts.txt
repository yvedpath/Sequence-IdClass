https://www.baeldung.com/hibernate-identifiers 

https://www.logicbig.com/tutorials/java-ee-tutorial/jpa/composite-primary-key.html - @IdClass Example


Identifiers: Identifiers in Hibernate represent the primary key of an entity. This implies the values are unique so that they can identify a specific entity,that they are not null and they will not be modified. 

Hibernate provides below ways to implement Identifiers: 

1] Simple Identifiers: This can be implemented with @Id annotation. This can be implemented for types : java primitives, primitive wrappers types, String, Date, BigDecimal and BigInteger. 

2] Generated Identifiers: If we want to automatically generate the primary key value, we can add @GeneratedValue annotation. This can use four generation types: AUTO,IDENTITY,SEQUENCE,TABLE 

2.1] AUTO generation: If we are using the default generation type, the persistence provider will determine values based on the type of the primary key attribute. This type can be numerical or UUID. 

2.2] IDENTITY generation: This type of generation relies on the IdentityGenerator, which expects values generated by an identity column in the database. This means they are auto-incremented. To use this generation type, we only need to set the strategy parameter. One thing to note is that IDENTITY generation disables batch updates. 

2.3] SEQUENCE Generation: To use a sequence-based id, Hibernate provides the SequenceStyleGenerator class. This generator uses sequences if our database supports them. It switches to table generation if they are not supported. 

2.4] TABLE generation: It uses underlying database table that holds segments of identifier generation values.

2.5] Custome generator: We can define our custom generator by implementing the IdentifierGenerator interface. 

3] Composite Identifiers: Hibernate also allows us to define composite identifiers. A composite id is represented by a primary key "class" with one or more persistenet attributes. The primary key class must fulfill several conditions: 
a) It should be defined using @EmbeddedId or @IdClass annotations
b) It should be public, serializable and have a public no-arg constructor. 
c) Finally, It should implement equals() and hashCode() methods. 
The class's attributes can be basic,composite or ManyToOne, while avoiding collections and OneToOne attributes. 

3.1] @EmbeddedId: First we need a primary key class annotated with @Embeddable 
@Embeddable
public class OrderEntryPK implements Serializable{
private long orderId;
private long productId;
//equals() and hashCode()
}

Next, We can add and id of type OrderEntryPK to an entity using @EmbeddedId: 
@Entity
public class OrderEntry{
@EmbeddedId
private OrderEntryPK entryId;
}

To set the primary key for an entity sing this type of composite Id: 

@Test
public void whenSaveCompositeIdEntity_thenOk(){
OrderEntryPK entryPK= new OrderEntryPK()
entryPK.setOrderId(1L);
entryPK.setProductId(30L);

OrderEntry entry=new OrderEntry();
entry.setEntryId(entryPK);
session.save(entry);
}
Here the OrderEntry object has an OrderEntryPK primary Id formed of two attributes: orderId and proudctId.  
 
3.2] @IdClass: 

This is similar to the @EmbeddedId. Difference is that the attributes are defnied in the main entity class using @Id for each one. The primary key class will look the same as before. 

@Entity
@IdClass(OrderEntryPK.class)
public class OrderEntry {
    @Id
    private long orderId;
    @Id
    private long productId;
    
    // ...
}

Then we can set the id values directly on the OrderEntry object: 
@Test
public void whenSaveIdClassEntity_thenOk() {        
    OrderEntry entry = new OrderEntry();
    entry.setOrderId(1L);
    entry.setProductId(30L);
    session.save(entry);

    assertThat(entry.getOrderId()).isEqualTo(1L);
}

Note that for both types of composite ids, the primary key class can also contain @ManyToOne attributes.

Hibernate also allows defining primary keys made up of @ManyToOne associations combined with @Id annotation. In this case, the entity class should also fulfill the conditions of a primary key class.

However, the disadvantage of this method is that there's no separation between the entity object and the identifie

4] Derived Identifers: 
Derived identifiers are obtained from an entity's association using the @MapsId annotation.


